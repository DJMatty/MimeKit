{"name":"MimeKit","tagline":"A C# MIME creation and parser library with support for S/MIME, PGP and Unix mbox spools","body":"# MimeKit\r\n\r\n## What is MimeKit?\r\n\r\nMimeKit is a C# library which may be used for the creation and parsing of messages using the Multipurpose Internet Mail Extension (MIME), as defined by the following RFCs:\r\n\r\n* [0822](http://www.ietf.org/rfc/rfc0822.txt): Standard for the Format of Arpa Internet Text Messages\r\n* [1341](http://www.ietf.org/rfc/rfc1341.txt): MIME (Multipurpose Internet Mail Extensions): Mechanisms for Specifying and Describing the Format of Internet Message Bodies\r\n* [1342](http://www.ietf.org/rfc/rfc1342.txt): Representation of Non-ASCII Text in Internet Message Headers\r\n* [1521](http://www.ietf.org/rfc/rfc1521.txt): MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies (Obsoletes rfc1341)\r\n* [1522](http://www.ietf.org/rfc/rfc1522.txt): MIME (Multipurpose Internet Mail Extensions) Part Two: Message Header Extensions for Non-ASCII Text (Obsoletes rfc1342)\r\n* [1544](http://www.ietf.org/rfc/rfc1544.txt): The Content-MD5 Header Field\r\n* [1847](http://www.ietf.org/rfc/rfc1847.txt): Security Multiparts for MIME: Multipart/Signed and Multipart/Encrypted\r\n* [1864](http://www.ietf.org/rfc/rfc1864.txt): The Content-MD5 Header Field (Obsoletes rfc1544)\r\n* [2015](http://www.ietf.org/rfc/rfc2015.txt): MIME Security with Pretty Good Privacy (PGP)\r\n* [2045](http://www.ietf.org/rfc/rfc2045.txt): Multipurpose Internet Mail Extensions (MIME) Part One: Format of Internet Message Bodies\r\n* [2046](http://www.ietf.org/rfc/rfc2046.txt): Multipurpose Internet Mail Extensions (MIME) Part Two: Media Types\r\n* [2047](http://www.ietf.org/rfc/rfc2047.txt): Multipurpose Internet Mail Extensions (MIME) Part Three: Message Header Extensions for Non-ASCII Text\r\n* [2048](http://www.ietf.org/rfc/rfc2048.txt): Multipurpose Internet Mail Extensions (MIME) Part Four: Registration Procedures\r\n* [2049](http://www.ietf.org/rfc/rfc2049.txt): Multipurpose Internet Mail Extensions (MIME) Part Five: Conformance Criteria and Examples\r\n* [2183](http://www.ietf.org/rfc/rfc2183.txt): Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field\r\n* [2184](http://www.ietf.org/rfc/rfc2184.txt): MIME Parameter Value and Encoded Word Extensions: Character Sets, Languages, and Continuations\r\n* [2231](http://www.ietf.org/rfc/rfc2231.txt): MIME Parameter Value and Encoded Word Extensions: Character Sets, Languages, and Continuations (Obsoletes rfc2184)\r\n* [2311](http://www.ietf.org/rfc/rfc2311.txt): S/MIME Version 2 Message Specification\r\n* [2312](http://www.ietf.org/rfc/rfc2312.txt): S/MIME Version 2 Certificate Handling\r\n* [2315](http://www.ietf.org/rfc/rfc2315.txt): PKCS #7: Cryptographic Message Syntax\r\n* [2424](http://www.ietf.org/rfc/rfc2424.txt): Content Duration MIME Header Definition\r\n* [2630](http://www.ietf.org/rfc/rfc2630.txt): Cryptographic Message Syntax\r\n* [2632](http://www.ietf.org/rfc/rfc2632.txt): S/MIME Version 3 Certificate Handling\r\n* [2633](http://www.ietf.org/rfc/rfc2633.txt): S/MIME Version 3 Message Specification\r\n* [2634](http://www.ietf.org/rfc/rfc2634.txt): Enhanced Security Services for S/MIME\r\n* [2822](http://www.ietf.org/rfc/rfc2822.txt): Internet Message Format (Obsoletes rfc0822)\r\n* [3156](http://www.ietf.org/rfc/rfc3156.txt): MIME Security with OpenPGP (Updates rfc2015)\r\n* [3850](http://www.ietf.org/rfc/rfc3850.txt): S/MIME Version 3.1 Certificate Handling (Obsoletes rfc2632)\r\n* [3851](http://www.ietf.org/rfc/rfc3851.txt): S/MIME Version 3.1 Message Specification (Obsoletes rfc2633)\r\n* [5322](http://www.ietf.org/rfc/rfc5322.txt): Internet Message Format (Obsoletes rfc2822) \r\n* [5750](http://www.ietf.org/rfc/rfc5750.txt): S/MIME Version 3.2 Certificate Handling (Obsoletes rfc3850)\r\n* [5751](http://www.ietf.org/rfc/rfc5751.txt): S/MIME Version 3.2 Message Specification (Obsoletes rfc3851)\r\n\r\n#### Other RFCs of interest:\r\n\r\n* [1523](http://www.ietf.org/rfc/rfc1523.txt): The text/enriched MIME Content-type\r\n* [1872](http://www.ietf.org/rfc/rfc1872.txt): The MIME Multipart/Related Content-type\r\n* [1927](http://www.ietf.org/rfc/rfc1927.txt): Suggested Additional MIME Types for Associating Documents\r\n* [2110](http://www.ietf.org/rfc/rfc2110.txt): MIME E-mail Encapsulation of Aggregate Documents, such as HTML (MHTML)\r\n* [2111](http://www.ietf.org/rfc/rfc2111.txt): Content-ID and Message-ID Uniform Resource Locators\r\n* [2112](http://www.ietf.org/rfc/rfc2112.txt): The MIME Multipart/Related Content-type (Obsoletes rfc1872)\r\n* [2387](http://www.ietf.org/rfc/rfc2387.txt): The MIME Multipart/Related Content-type (Obsoletes rfc2112)\r\n\r\n## License Information\r\n\r\nMimeKit is Copyright (C) 2012, 2013 Jeffrey Stedfast and is licensed under the MIT/X11 license:\r\n\r\n    Permission is hereby granted, free of charge, to any person obtaining a copy\r\n    of this software and associated documentation files (the \"Software\"), to deal\r\n    in the Software without restriction, including without limitation the rights\r\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n    copies of the Software, and to permit persons to whom the Software is\r\n    furnished to do so, subject to the following conditions:\r\n\r\n    The above copyright notice and this permission notice shall be included in\r\n    all copies or substantial portions of the Software.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n    THE SOFTWARE.\r\n\r\n## History\r\n\r\nAs a developer and user of Electronic Mail clients, I had come to realize that the vast majority of E-Mail client\r\n(and server) software had less-than-satisfactory MIME implementations. More often than not these E-Mail clients\r\ncreated broken MIME messages and/or would incorrectly try to parse a MIME message thus subtracting from the full\r\nbenefits that MIME was meant to provide. MimeKit is meant to address this issue by following the MIME specification\r\nas closely as possible while also providing programmers with an extremely easy to use high-level API.\r\n\r\nThis led me, at first, to implement another MIME parser library called [GMime](http://spruce.sourceforge.net/gmime)\r\nwhich is implemented in C and later added a C# binding called GMime-Sharp.\r\n\r\nNow that I typically find myself working in C# rather than lower level languages like C, I decided to\r\nbegin writing a new parser in C# which would not depend on GMime. This would also allow me to have more\r\nflexibility in that I'd be able use Generics and create a more .NET-compliant API.\r\n\r\n## Building\r\n\r\nFirst, you'll need to clone MimeKit and Bouncy Castle from my GitHub repository:\r\n\r\n    git clone https://github.com/jstedfast/MimeKit.git\r\n    git clone https://github.com/jstedfast/bc-csharp.git\r\n\r\nCurrently, MimeKit depends on the visual-studio-2010 branch of bc-csharp for the Visual Studio 2010 project\r\nfiles that I've added (to replace the Visual Studio 2003 project files). To switch to that branch,\r\n\r\n    cd bc-csharp\r\n    git checkout -b visual-studio-2010 origin/visual-studio-2010\r\n\r\nIn the top-level MimeKit source directory, there are two solution files: MimeKitDesktopOnly.sln and MimeKit.sln.\r\n\r\nMimeKitDesktopOnly.sln just includes the .NET Framework 4.0 C# project (MimeKit/MimeKit.csproj) and the UnitTests\r\nproject (UnitTests/UnitTests.csproj).\r\n\r\nMimeKit.sln includes everything that is in the MimeKitDesktopOnly solution as well as the projects for Xamarin.Android,\r\nXamarin.iOS, and Xamarin.Mac.\r\n\r\nIf you don't have the Xamarin products, you'll probably want to open the MimeKitDesktopOnly.sln instead of MimeKit.sln.\r\n\r\nOnce you've opened the appropriate MimeKit solution file in either Xamarin Studio or Visual Studio 2010+ (either will work),\r\nyou can simply choose the Debug or Release build configuration and then build.\r\n\r\nNote: The Release build will generate the xml API documentation, but the Debug build will not.\r\n\r\n## Using MimeKit\r\n\r\n### Parsing Messages\r\n\r\nOne of the more common operations that MimeKit is meant for is parsing email messages from arbitrary streams.\r\nThere are two ways of accomplishing this task.\r\n\r\nThe first way is to use one of the Load() methods on MimeKit.MimeMessage:\r\n\r\n    // Load a MimeMessage from a stream\r\n    var message = MimeMessage.Load (stream);\r\n\r\nThe second way is to use the MimeParser class. For the most part, using the MimeParser directly is not necessary\r\nunless you wish to parse a Unix mbox file stream. However, this is how you would do it:\r\n\r\n    // Load a MimeMessage from a stream\r\n    var parser = new MimeParser (stream, MimeFormat.Entity);\r\n    var message = parser.ParseMessage ();\r\n\r\nFor Unix mbox file streams, you would use the parser like this:\r\n\r\n    // Load every message from a Unix mbox\r\n    var parser = new MimeParser (stream, MimeFormat.Mbox);\r\n    while (!parser.IsEndOfStream) {\r\n        var message = parser.ParseMessage ();\r\n        \r\n        // do something with the message\r\n    }\r\n\r\n### Traversing a MimeMessage\r\n\r\nOnce you have parsed a MimeMessage, you'll most likely want to traverse the tree of MIME entities.\r\n\r\nThe MimeMessage.Body is the top-level MIME entity of the message. Generally, it will either be a\r\nTextPart or a Multipart.\r\n\r\nAs an example, if you wanted to render the MimeMessage to some sort of UI control, you might\r\nuse code similar to this:\r\n\r\n    void RenderMessage (MimeMessage message)\r\n    {\r\n        RenderMimeEntity (message.Body);\r\n    }\r\n\r\n    void RenderMimeEntity (MimeEntity entity)\r\n    {\r\n        if (entity is MessagePart) {\r\n            // This entity is an attached message/rfc822 mime part.\r\n            var messagePart = (MessagePart) entity;\r\n           \r\n            // If you'd like to render this inline instead of treating\r\n            // it as an attachment, you would just continue to recurse:\r\n            RenderMessage (messagePart.Message);\r\n        } else if (entity is Multipart) {\r\n            // This entity is a multipart container.\r\n            var multipart = (Multipart) entity;\r\n            \r\n            foreach (var subpart in multipart)\r\n                RenderMimeEntity (subpart);\r\n        } else {\r\n            // Everything that isn't either a MessagePart or a Multipart is a MimePart\r\n            var part = (MimePart) entity;\r\n            \r\n            // Don't render anything that is explicitly marked as an attachment.\r\n            if (part.IsAttachment)\r\n                return;\r\n            \r\n            if (part is TextPart) {\r\n                // This is a mime part with textual content.\r\n                var text = (TextPart) part;\r\n                \r\n                if (text.ContentType.Matches (\"text\", \"html\"))\r\n                    RenderHtml (text.Text);\r\n                else\r\n                    RenderText (text.Text);\r\n            } else if (entity.ContentType.Matches (\"image\", \"*\")) {\r\n                using (var content = new MemoryStream ()) {\r\n                    // If the content is base64 encoded (which it probably is), decode it.\r\n                    part.ContentObject.DecodeTo (memory);\r\n                    \r\n                    RenderImage (memory);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n### Verifying S/MIME and PGP/MIME Digital Signatures\r\n\r\nBoth S/MIME and PGP/MIME use a multipart/signed to contain the signed content and the detached signature data.\r\n\r\nA multipart/signed contains exactly 2 parts: the first MimeEntity is the signed content while the second\r\nMimeEntity is the detached signature and, by default, will either be an ApplicationPgpSignature part or\r\nan ApplicationPkcs7Signature part.\r\n\r\nBecause the multipart/signed part may have been signed by multiple signers, it is important to\r\nverify each of the digital signatures (one for each signer) that are returned by the\r\nMultipartSigned.Verify() method:\r\n\r\n    if (entity is MultipartSigned) {\r\n        var signed = (MultipartSigned) entity;\r\n        \r\n        foreach (var signature in signed.Verify ()) {\r\n            try {\r\n                bool valid = signature.Verify ();\r\n                \r\n                // If valid is true, then it signifies that the signed content has not been\r\n                // modified since this particular signer signed the content.\r\n                //\r\n                // However, if it is false, then it indicates that the signed content has been\r\n                // modified.\r\n            } catch (DigitalSignatureVerifyException) {\r\n                // There was an error verifying the signature.\r\n            }\r\n        }\r\n    }\r\n\r\n## Contributing\r\n\r\nThe first thing you'll need to do is fork MimeKit to your own GitHub repository. Once you do that,\r\n\r\n    git clone git@github.com/<your-account>/MimeKit.git\r\n\r\nIf you use [Xamarin Studio](http://xamarin.com/studio) or [MonoDevelop](http://monodevelop.org), both MimeKit.sln\r\nand MimeKitDesktopOnly.sln are configured with the coding style used by MimeKit. If you use Visual Studio or some\r\nother editor, please try to maintain the existing coding style as best as you can.\r\n\r\nOnce you've got some changes that you'd like to submit upstream to the official MimeKit repository,\r\nsimply send me a Pull Request and I will try to review your changes in a timely manner.\r\n\r\n## Reporting Bugs\r\n\r\nHave a bug or a feature request? [Please open a new issue](https://github.com/jstedfast/MimeKit/issues).\r\n\r\nBefore opening a new issue, please search for existing issues to avoid submitting duplicates.\r\n\r\n## Documentation\r\n\r\nAPI documentation can be found in the docs/ directory.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}